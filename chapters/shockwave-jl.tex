\chapter{Το πακέτο Shockwave.jl}

\section{Σκοπός του πακέτου}

Όπως είδαμε στο κεφάλαιο \ref{chapter:julia-diffeq}, η Julia παρέχει ένα αρκετά ανεπτυγμένο σύστημα επίλυσης συστημάτων συνηθών διαφορικών εξισώσεων (ODE).
Επίσης, στο κεφάλαιο \ref{chapter:theory}, είδαμε πως μπορούμε να επιλύσουμε αριθμητικά το σύστημα μερικών διαφορικών εξισώσεων (PDE) του Euler για την συμπιεστή ροή των ρευστών, κατασκευάζοντας ένα σύστημα συνηθών διαφορικών εξισώσεων που μοντελοποιούν την εξέλιξη των αριθμητικών συντελεστών που ορίζουν την προσέγγιση της λύσης σε κάθε χρονική στιγμή.

Ερχόμαστε λοιπόν στην κύρια συνεισφορά αυτής της εργασίας, η οποία είναι η ανάπτυξη ενός πακέτου το οποίο επιτρέπει την περιγραφή ενός προβλήματος νόμου διατήρησης (conservation law), από την οποία κατασκευάζει ένα σύστημα ODE το οποίο ο χρήστης μπορεί να επιλύσει με την ευελιξία του \jlinl{DifferentialEquations.jl} όπως περιγράφεται στο κεφάλαιο \ref{chapter:julia-diffeq}.
Με αυτόν τον τρόπο, έχουμε μία αναχώρηση από το τυπικό μοντέλο επιλυτών ρευστομηχανικής που συνήθως αποτελούν μεγάλα μονολιθικά προγράμματα.
Με το πακέτο της εργασίας, η μέθοδος πεπερασμένων όγκων και το φυσικό μοντέλο του ρευστού είναι πλέον ένα σύνολο συναρτήσεων και δομών δεδομένων, σχεδιασμένων να μπορούν να ενσωματωθούν σε μεγαλύτερα προγράμματα, ακολουθώντας έτσι την φιλοσοφία σχεδίασης της Julia.
Ως όνομα για το πακέτο επιλέχθηκε ο τίτλος \jlinl{Shockwave.jl}, καθώς ως βασικός στόχος, τουλάχιστον της αρχικής ανάπτυξης, είναι η επίλυση των συμπιεστών εξισώσεων Euler.

Όσον αφορά τον τρόπο περιγραφής του προβλήματος προς επίλυση υπάρχει ένα φάσμα προσεγγίσεων, όπου χρειάζεται να διαλέξουμε ανάμεσα στην συντομία της περιγραφής και στην γενικότητά της.
Στην συγκεκριμένη περίπτωση, αντλούμε έμπνευση από το πακέτο \jlinl{OrdinaryDiffEq.jl} που επιτρέπει την επίλυση συστημάτων ODE, παρέχοντας μία συνάρτηση που υπολογίζει την χρονική παράγωγο σε κάθε χρονική στιγμή, το χρονικό διάστημα ολοκλήρωσης, και τον αλγόριθμο ολοκλήρωσης.
Αντίστοιχα, το πακέτο \jlinl{Shockwave.jl}, περιγράφει ένα πρόβλημα νόμου διατήρησης (conservation law), ή εναλλακτικά μεταφοράς (advection), ως συνδιασμό τριών στοιχείων:

\begin{itemize}
    \item την συνάρτηση υπολογισμού της ροής $\mathbf{F}$ ανάμεσα σε δύο γειτονικά στοιχεία,
    \item το πλέγμα πάνω στο οποίο το πρόβλημα επιλύεται, και
    \item την αριθμητική μέθοδο χωρικής διακριτοποιήσης (π.χ. πεπερασμένοι όγκοι N-τάξης, ασυνεχής μέθοδος Galerkin (Discontinuous Galerkin/DG), κ.α.). Προς το παρόν η μόνη διαθέσιμη μέθοδος είναι οι πεπερασμένοι όγκοι πρώτης τάξης.
\end{itemize}

Έτσι με βάση τα παραπάνω, μπορούμε να ορίσουμε τον τύπο δεδομένων που αναπαριστά ένα τέτοιο πρόβλημα:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
struct AdvectionProblem{N, F, D, M}
    # Field names
    fields::NTuple{N, Symbol}

    # Flux function
    f::F

    # Mesh
    m::M

    function AdvectionProblem(fields::NTuple{N, Symbol}, f::F, ::D, m::M) where
            {N, F, D <: AbstractDiscretization, M <: AbstractMesh}
        new{N, F, D, M}(fields, f, m)
    end
end

# Supported discretization methods
struct FV1 <: AbstractDiscretization end # Finite Volume Method - 1st-order
\end{jllisting}
}

Αρχικά παρατηρούμε ότι οι παραμέτροι που αναφέραμε παραπάνω, δεν αποθηκεύονται ως τιμές αλλά ως τύποι δεδομένων.
Αυτό είναι μία συνηθισμένη τεχνική στην Julia καθώς επιτρέπει να ξεχωρίσουμε την λογική που πρέπει να εκτελεστεί κατά την μεταγλώττιση, από αυτήν του χρόνου εκτέλεσης, και μας επιτρέπει να εκφράσουμε τον πολυμορφισμό που θέλουμε χρησιμοποιώντας το σύστημα multiple dispatch.

Επίσης, χρειάζεται να ορίσουμε τα βαθμωτά πεδία του προβλήματος.
Αυτό επιτρέπει να ορίσουμε βοηθητικές συναρτήσεις που αυτόματα εκχωρούν μνήμη για τα δεδομένα της λύσης, και γράφουν τα αποτελέσματα σε αρχεία VTK με κατάλληλες ετικέτες.
Πέρα από αυτό, οι ετικέτες δεν χρειάζονται σε κάτι κατά την διάρκεια της επίλυσης.
Βασικότερος είναι ο ακέραιος \jlinl{N}, που ορίζει τον αριθμό των βαθμωτών πεδίων.

Είπαμε όμως ότι χρειάζεται εν τέλει να παράξουμε μία συνάρτηση η οποία υπολογίζει την χρονική παράγωγο.
Ένας τρόπος να το κάνουμε αυτό, θα ήταν η δυναμική παραγωγή κώδικα και χρήση των λεγόμενων \emph{generated functions}.
Υπάρχει ένας όμως σημαντικά απλούστερος τρόπος να πετύχουμε κάτι παρόμοιο, καθώς η Julia μας επιτρέπει να ορίσουμε μία συνάρτηση για κάθε τύπο δεδομένων, η οποία καλείται εάν καλέσουμε το αντικείμενο σαν συνάρτηση.
Πρακτικά, για τον παραπάνω τύπο \jlinl{AdvectionProblem}, μπορούμε να ορίσουμε μία συνάρτηση της μορφής:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
function (p::AdvectionProblem)(du, u, param, time)
    # Compute and fill du
end
\end{jllisting}
}

Με αυτόν τον τρόπο, μπορούμε να χρησιμοποιήσουμε ένα αντικείμενο τύπου \jlinl{AdvectionProblem} ως την συνάρτηση της χρονικής παραγώγου που χρειαζόμαστε για να ορίσουμε ένα \jlinl{ODEProblem}.

\section{Συνάρτηση υπολογισμού ροής}

Η συνάρτηση υπολογισμού της ροής είναι ο μοναδικός τρόπος με τον οποίο ο χρήστης μπορεί να καθορίσει τον φυσικό νόμο του προβλήματος.
Αυτή έχει την μορφή

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
function F(UL, UR, n)
    SVector(...)
end
\end{jllisting}
}

όπου \jlinl{UL}, είναι ένα διάνυσμα μήκους \jlinl{N}, που περιέχει τους συντελεστές της λύσης στο εσωτερικό του στοιχείου, \jlinl{UR} το διάνυσμα της λύσης στο εξωτερικό του στοιχείου, και \jlinl{n}, το μοναδιαίο διάνυσμα κάθετο στην επιφάνεια του ορίου.
Η συνάρτηση αυτή επιστρέφει ένα διάνυσμα μήκους \jlinl{N} που περιέχει την ροή προς το εξωτερικό του πεπερασμένου όγκου για το κάθε βαθμωτό πεδίο.

\section{Πλέγμα}

Το πλέγμα ορίζει τόσο την τοπολογία των στοιχείων, όσο και την ακριβή γεωμετρία τους στον χώρο.
Ο μοναδικός τύπος πλέγματος που υποστηρίζεται από το πακέτο είναι το δυδιάστατο μη-δομημένο πλέγμα (2D unstructured grid), που αποτελείται από τριγωνικά στοιχεία, αλλά δεν υπάρχει κάτι στην σχεδίαση του πακέτου που να εμποδίζει την μελλοντική προσθήκη, π.χ. δομημένων καμπυλόγραμμων πλεγμάτων (structured curvilinear grid).

Το μη δομημένο πλέγμα, ορίζεται από την δομή δεδομένων \jlinl{UnstructuredMesh}, ως εξής:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
@enum ElementType begin
    TriangleElement
    LineElement
end

struct Triangle{F, I}
    vert::SVector{3, I} # Vertices
    n::SVector{3, Vector2{F}} # Normal vectors
    l::SVector{3, F} # Edge lengths
    nb::SVector{3, I} # Neigbors
    area::F # Area
end

struct Line{F, I}
    vert::SVector{2, I}
    l::F # Length
    n::Vector2{F} # Normal vector pointing *into* the domain
    nb::I # Neighbor
end

struct Element{I}
    type::ElementType
    idx::I # Local index
end

struct UnstructuredMesh{AV, AE, AT, AL, F, I} <: AbstractMesh
    # Nodes (vector of Vector2)
    nodes::AV

    # Elements (vector of Element)
    elements::AE

    # Triangles (vector of Triangle)
    triangles::AT

    # Lines (vector of Line)
    lines::AL

    # Marked boundaries
    groups::Array{Int, 2} # (group number, first line index|group size)

    # Group name -> index of group in the groups array
    groupnames::Dict{String, Int}
end
\end{jllisting}
}

Η επιλογή του συγκεκριμένου τρόπου αναπαράστασης του διδιάστατου πλέγματος, έγινε με το σκεπτικό οι προσπελάσεις μνήμης που απαιτούνται σε κάθε επανάληψη να ελαχιστοποιηθούν.
Έτσι, κατά την προεπεξεργασία του πλέγματος, υπολογίζουμε πλήρως όλα τα κάθετα διανύσματα, τα μήκη πλευρών και της επιφάνειες των στοιχείων.
Επίσης, ξεχωρίζουμε τα στοιχεία ανάμεσα σε τρίγωνα και ευθύγραμμα τμήματα, τα οποία αποτελούν τα όρια του υπολογιστικού χώρου.
Το κάθε στοιχείο έχει μία καθολική θέση (global index), και μία τοπική θέση (local index).
Αυτές αναφέρονται στην θέση του στοιχείου στον πίνακα με όλα τα στοιχεία, που έχει ίδια μορφή με το διάνυσμα της λύσης, και στους πίνακες για την κάθε κατηγορία στοιχείου, που περιέχουν τις γεωμετρικές πληροφορίες.
Καθώς τα τρίγωνα είναι σημαντικά περισσότερα και χρειάζεται να τα προσπελάσουμε πολύ περισσότερες φορές, η τοπική και η καθολική τους θέση ταυτίζονται, ενώ για τα ευθύγραμμα τμήματα, διαφέρουν κατά τον αριθμό των τριγώνων, δηλαδή βρίσκονται μετά από όλα τα τρίγωνα στον πίνακα των στοιχείων.

Τα όρια αποτελούνται αποκλειστικά από ευθύγραμμα τμήματα, και στα περισσότερα προγράμματα παραγωγής πλεγμάτων, ο χρήστης μπορεί να τους δώσει μία φιλική ονομασία.
Καθώς τα ευθύγραμμα τμήματα για κάθε όριο είναι αποθηκευμένα στην σειρά, μπορούμε να ορίσουμε ένα όριο με το δίαστημα των θέσεων των ευθυγράμμων τμημάτων από τα οποία αποτελείται, δηλαδή την θέση του πρώτου και του τελευταίο ευθύγραμμου τμήματός του.
Για λόγους απόδοσης, αυτοί οι αριθμοί αποθηκεύονται σε μία συνεκτική (compact) δομή δεδομένων, στην συγκεκριμένη περίπτωση έναν διδιάστατο πίνακα, αλλά οι φιλικές ονομασίες των ορίων είναι διαθέσιμες από το λεξικό \jlinl{groupnames}, και χρησιμοποιούνται κατά τον ορισμό οριακών συνθηκών, όπως θα δούμε στην ενότητα \ref{section:shockwave-bcs}.

Το πακέτο παρέχει την δυνατότητα ανάγνωσης διδιάστατων πλεγμάτων με τριγωνικά στοιχεία στην μορφή που δέχεται ο επιλυτής SU2 \cite{Palacios2013}.
Αυτή η μορφή υποστηρίζεται ως μορφή εξόδου από διάφορα προγράμματα παραγωγής πλεγμάτων, συμπεριλαμβανομένου του λογισμικού ανοικτού κώδικα Gmsh \cite{Gmsh2009}.

\section{Παράδειγμα: μεταφορά βαθμωτού πεδίου σε σταθερό πεδίο ροής}

Ως επίδειξη του τρόπου λειτουργίας των τμήματων που περιγράψαμε παραπάνω, ας εξετάσουμε την επίλυση του εξής απλού προβλήματος.
Έστω ότι έχουμε ένα τετράγωνο χώρο, που εκτείνεται από το σημείο $\left(0, 0\right)$ μέχρι το σημείο $\left(1, 1\right)$.
Σε αυτόν τον χώρο, ορίζουμε το εξής διανυσματικό πεδίο ταχύτητας:

\begin{equation*}
    \mathbf{V} = - \sin \pi x \cos \pi y \mathbf{i} + \cos \pi x \sin \pi y \mathbf{j}
\end{equation*}

% todo generate quiver plot of the field

Έστω τώρα ότι σε αυτόν τον χώρο ορίζουμε ένα βαθμωτό πεδίο $U$, του οποίου την μεταφορά θέλουμε να προσομοιώσουμε.
Με άλλα λόγια, θέλουμε να λύσουμε την διαφορική εξίσωση:

\begin{equation*}
    \frac{\mathrm{D} U}{\mathrm{D} t} = \frac{\partial U}{\partial t} + \mathbf{V} \cdot \nabla U =
        \frac{\partial U}{\partial t} + \nabla \cdot \left( \mathbf{V} U \right) = 0
\end{equation*}

όπου $\nabla \cdot \left( \mathbf{V} U \right) = \mathbf{V} \cdot \nabla U$, καθώς $\nabla \cdot \mathbf{V} = 0$.

Συγκρίνοντας την παραπάνω εξίσωση με την \ref{eq:advection-point-form}, προκύπτει η συνάρτηση ροής ως:

\begin{equation*}
    \mathbf{F} = \mathbf{V} U
\end{equation*}

Για να βρούμε την μορφή της συνάρτησης ροής που μπορούμε να χρησιμοποιήσουμε πάνω στο ασυνεχές όριο, ας θεωρήσουμε ότι λύνουμε το πρόβλημα κατά μήκος του κάθετου διανύσματος $\mathbf{\hat{n}}$, παράλληλα στο οποίο ορίζουμε έναν χωρικό άξονα συντεταγμένων, έστω $z$.
Τότε, γραμμικοποιώντας το πρόβλημα, έχουμε:

\begin{equation*}
    \frac{\partial U}{\partial t} + \frac{\partial (\mathbf{V} \cdot \mathbf{\hat{n}}) U}{\partial z} 
    \approx \frac{\partial U}{\partial t} + \left( \mathbf{V} \cdot \mathbf{\hat{n}} \right) \frac{\partial U}{\partial z} = 0
\end{equation*}

Εφαρμόζοντας την τεχνική Flux Vector Splitting (FVS), βλέπουμε ότι έχουμε ένα κύμα που διαδίδεται κατά την φορά του διανύσματος $\left( \mathbf{V} \cdot \mathbf{\hat{n}} \right) \mathbf{\hat{n}}$ με ταχύτητα $\mathbf{V} \cdot \mathbf{\hat{n}}$, άρα

\begin{align*}
    \mathbf{F} = 
    \mathbf{F}_{+} + \mathbf{F}_{-} &=
        \begin{cases}
            \left| \mathbf{V} \cdot \mathbf{\hat{n}} \right | U_{-} & \mathbf{V} \cdot \mathbf{\hat{n}} > 0 \\
            0 & \mathbf{V} \cdot \mathbf{\hat{n}} < 0
        \end{cases}
    +
        \begin{cases}
            0 & \mathbf{V} \cdot \mathbf{\hat{n}} > 0 \\
            -\left| \mathbf{V} \cdot \mathbf{\hat{n}} \right | U_{+} & \mathbf{V} \cdot \mathbf{\hat{n}} < 0
        \end{cases} \\
    \mathbf{F} &=
        \begin{cases}
            \left| \mathbf{V} \cdot \mathbf{\hat{n}} \right | U_{+} & \mathbf{V} \cdot \mathbf{\hat{n}} > 0 \\
            -\left| \mathbf{V} \cdot \mathbf{\hat{n}} \right | U_{-} & \mathbf{V} \cdot \mathbf{\hat{n}} < 0
        \end{cases}
\end{align*}

Η μεταφορά της παραπάνω εξίσωσης σε κώδικα Julia είναι αρκετά ξεκάθαρη:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
function advectionflux(UL, UR, n)
    TL, vxL, vyL = UL
    TR, vxR, vyR = UR

    v = 0.5 .* SVector(vxL + vxR, vyL + vyR)

    V = n ⋅ v
    FT = if V ≥ 0
        TL * V
    else
        TR * V
    end

    SVector(FT, 0.0, 0.0)
end
\end{jllisting}
}

όπου για την ταχύτητα πάνω στο όριο παίρνουμε τον μέσο όρο των ταχυτήτων στις δύο μεριές του ορίου.
Επίσης, ορίζουμε τα \jlinl{UL} και \jlinl{UR} να είναι διανύσματα που περιέχουν και την τοπική ταχύτητα, και άρα τα \jlinl{TL}, και \jlinl{TR} αντιστοιχούν στα $U_{-}$ και $U_{+}$ αντίστοιχα.

\section{Οριακές συνθήκες}
\label{section:shockwave-bcs}

% boundary conditions with callbacks

\section{Παράδειγμα: αεροτομή σε σχήμα ρόμβου}

% Introduce example problem, diamond airfoil

\section{Επιτάχυνση με CUDA}

% GPU acceleration
% Adapt data structs to GPU, write custom kernel for unstructured mesh/FV1

\section{Εναλλακτικές προσεγγίσεις}

% Describe other approaches

% Previous work - Look at other Julia packages
% Mention Liszt
% Trixi.jl (Great but no GPU acceleration, focuses on AMR)

