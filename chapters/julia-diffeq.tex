\chapter{Επίλυση διαφορικών εξισώσεων με Julia}
\label{chapter:julia-diffeq}

Σε αυτό το κεφάλαιο θα ασχοληθούμε με τον τρόπο λειτουργίας της γλώσσας προγραμματισμού Julia και τις τεχνικές επίλυσης διαφορικών εξισώσεων με αυτήν.
Θα εξετάσουμε επίσης της δυνατότητες προγραμματισμού καρτών γραφικών που παρέχονται από τα πακέτα της ομάδας JuliaGPU.

\section{Η γλώσσα προγραμματισμού Julia}

\subsection{Το πρόβλημα των δύο γλωσσών}

Όπως αναφέρθηκε και στην εισαγωγή, η Julia στοχεύει στην επίλυση του λεγόμενου \emph{προβλήματος των 2 γλωσσών}.
Το πρόβλημα αυτό είναι προϊόν της μέχρι τώρα αρνητικής συσχέτισης ανάμεσα στην εκφραστικότητα μίας γλώσσας προγραμματισμού και την απόδοση ιδιωματικού κώδικα σε αυτήν.
Με άλλα λόγια, η πρωτοτυποποίηση ενός αλγορίθμου μπορεί να γραφεί εύκολα σε μία γλώσσα όπως η Python, αλλά αυτό μπορεί να συνεπάγεται μιας απώλειας σε ταχύτητα μίας τάξης μεγέθους.
Ως αποτέλεσμα, είναι συνήθες επιστήμονες ή μηχανικοί να γράφουν αρχικά μία υλοποίηση του αλγορίθμου που θέλουν να εκτελέσουν σε μία αργή αλλά υψηλού επιπέδου γλώσσα προκειμένου να ελέγξουν την ορθότητα του, και ύστερα να ξαναγράφουν αυτόν τον αλγόριθμο σε μία γλώσσα όπως η C++ ή η Fortran προκειμένου να επιτύχουν καλή ταχύτητα.

Ένας τρόπος επίλυσης αυτού του προβλήματος προκύπτει από την παρατήρηση ότι ο περισσότερος χρόνος εκτέλεσης προκαλείται από ένα κομμάτι του προγράμματος σημαντικά μικρότερο από το σύνολο του κώδικα του προγράμματος.
Κατά βάση, αυτός είναι ο κώδικας που βρίσκεται στο εσωτερικό βρόγχων, ειδικά όταν αυτοί οι βρόγχοι βρίσκονται ο ένας μέσα στον άλλον, και μπορεί να είναι π.χ. ο κώδικας που εκτελεί ένα βήμα μίας επαναληπτικής αριθμητικής μεθόδου.
Μπορούμε λοιπόν να απομονώσουμε αυτά τα κομμάτια κώδικα και να τα γράψουμε σε μία γλώσσα χαμηλού επιπέδου και υψηλής απόδοσης, ενώ ο υπόλοιπος συνδετικός κώδικας ο οποίος συνεισφέρει ένα αμελητέο κομμάτι του χρόνου εκτέλεσης μπορεί να γραφεί σε μία γλώσσα υψηλού επιπέδου.

Αυτή η προσέγγιση χρησιμοποιείται κατά κόρον σε συστήματα μηχανιστικής μάθησης (machine learning) όπως το TensorFlow και το PyTorch, όπου η γλώσσα χαμηλού επιπέδου είναι η C++ (και διαλέκτοι της C++ για προγραμματισμό καρτών γραφικών όπως η CUDA ή το HIP) ενώ η γλώσσα υψηλού επιπέδου είναι η Python ή και η Swift στην περίπτωση του TensorFlow.
Αυτή η αρχιτεκτονική έχει δουλέψει αρκετά καλά για την περίπτωση των νευρωνικών δικτύων (neural networks) όπου μεγάλο μέρος της έρευνας είναι ο σωστός συνδιασμός γνωστών block έτσι ώστε ένα πρόβλημα να επιλυθεί με ικανοποιητική ακρίβεια.
Μάλιστα, είναι αρκετά συχνό ένα ερευνητικό αποτέλεσμα να διανέμεται ως μίξη κώδικα υψηλού επιπέδου και κειμένου με την μορφή διαδραστικών notebook, με την χαμηλού επιπέδου υλοποίηση των αλγορίθμων μάθησης να μην αναφέρεται καν.

Ο διαχωρισμός ανάμεσα σε γρήγορο και αργό κώδικα όμως, έχει μία σειρά από μειονεκτήματα:
Αρχικά, όλη η επικοινωνία ανάμεσα στις δύο γλώσσες μπορεί να γίνει με τον μέγιστο κοινό διαιρέτη των δυνατοτήτων τους, το οποίο στην πράξη συνήθως σημαίνει ότι ο χαμηλού επιπέδου κώδικας παρέχει μία διεπαφή (interface) από συναρτήσεις C.
Αυτό σημαίνει ότι είναι αδύνατον π.χ. ο κώδικας σε C++ να χρησιμοποιήσει μία ανώνυμη συνάρτηση (ή αλλιώς συνάρτηση λάμδα), ορισμένη στον υψηλού επιπέδου κώδικα σε Python, παρόλο που και οι δύο γλώσσες υποστηρίζουν συναρτήσεις ως τύπους δεδομένων.

Ύστερα, κατά την συγγραφή του χαμηλού επιπέδου κώδικα, συνεχίζουμε να αναγκαζόμαστε να υλοποιήσουμε τον αλγόριθμό μας στην γλώσσα υψηλού επιπέδου για να τον επαληθεύσουμε, εκτός εάν η λογική του είναι αρκετά απλή και προφανής.
Με άλλα λόγια, η συγγραφή του χαμηλού επιπέδου κώδικα είναι πιο χρονοβόρα καθώς δεν μπορούμε να χρησιμοποιήσουμε χρήσιμα χαρακτηριστικά γλωσσών υψηλού επιπέδου, όπως δυναμικούς τύπους ή διαδραστικά περιβάλλοντα ανάπτυξης με γρήγορο χρόνο απόκρισης στις αλλαγές μας όπως notebook ή συστήματα REPL.

Τέλος, καθώς τροποποιήσεις στον χαμηλού επιπέδου κώδικα είναι σημαντικά δυσκολότερες, χρήστες και ερευνητές αποθαρρύνονται σημαντικά από το να κάνουν πειράματα που απαιτούν τροποποιήσεις των χαμηλού επιπέδου αλγορίθμων.
Αυτό αυξάνει τον φόρτο εργασίας των προγραμματιστών που αναπτύσουν αυτόν τον κώδικα, και μειώνει το κίνητρο για την υλοποίηση πειραματικών, μή δοκιμασμένων υπολογιστικών τεχνικών, καθώς το κόστος υλοποίησής τους είναι πολύ μεγάλο, ειδικά για χρήστες που δεν έχουν επιρροή στην ομάδα ανάπτυξης των βιβλιοθηκών αυτών.

\subsection{Το μοντέλο προγραμματισμού της γλώσσας Julia}

\subsubsection{Σχεδιαστικές επιλογές}

Στην προηγούμενη ενότητα αναφερθήκαμε στο πρόβλημα των δύο γλωσσών, και στην επιλογή ανάμεσα σε μία αργή αλλά υψηλού επιπέδου γλώσσας και μία γρήγορη αλλά χαμηλού επιπέδου γλώσσα.
Υπάρχουν αρκετοί παράγοντες για την διαφορά σε απόδοση ανάμεσα σε ιδιοματικά προγράμματα ανάμεσα σε δύο γλώσσες, αλλά τα παρακάτω χαρακτηριστικά μίας γλώσσας μπορούν να έχουν σημαντικό αντίκτυπο στην απόδοσή της:

\begin{itemize}
    \item Διερμηνεία (interpretation) αντί μεταγλώττισης (compilation).
        Πολλές υψηλού επιπέδου γλώσσες (π.χ. Python, Lua, Ruby) αλλά όχι όλες εκτελούνται μέσω διερμηνείας (interpreted languages).
        Αυτό σημαίνει ότι ο χρόνος εκτέλεσης περιλαμβάνει τον χρόνο συντακτικής ανάλυσης και κατανόησης του πηγαίου κώδικα από την μηχανή εκτέλεσης.
        Προς μείωση αυτού του χρόνου, γλώσσες όπως η Python παρέχουν έναν τρόπο αποθήκευσης κώδικα μετά το στάδιο του parsing μειώνοντας κάπως τον χρόνο της διερμηνείας, αλλά η συντακτική ανάλυση παραμένει μία υπολογιστικά ακριβή διαδικασία.
        Ένα δεύτερο αρνητικό αποτέλεσμα της διερμηνείας είναι ότι οι αλγόριθμοι και οι βελτιστοποιήσεις που μπορεί να εκτελέσει το σύστημα διερμηνείας πρέπει αναγκαστικά να είναι σχετικά απλοί και γρήγοροι, το οποίο επίσης αυξάνει τον χρόνο εκτέλεσης.
    \item Τρόπος διαχείρησης μνήμης. Οι υψηλού επιπέδου γλώσσες έχουν κατά κανόνα ένα σύστημα αυτόματης διαχείρησης μνήμης με την μορφή ενός Garbage Collector (GC).
        Αυτό κάνει την συγγραφή προγραμμάτων σημαντικά ευκολότερη καθώς ο προγραμματιστής δεν χρειάζεται να ασχοληθεί με τον χρόνο για τον οποίο μία εκχώρηση μνήμης είναι απαραίτητη και πότε αυτή μπορεί να αποδεσμευθεί.
        Αποφεύγονται επίσης μία σειρά από συχνά λάθη προγραμματισμού σχετικά με την διαχείρηση μνήμης (double-free, null pointer exception κ.α.), το οποίο μπορεί να μειώσει σημαντικά τον χρόνο ανάπτυξης.
        Το κόστος για αυτά τα πλεονεκτήματα είναι ότι αναγκαστικά ένα κομμάτι του χρόνου εκτέλεσης θα πρέπει να αφιερωθεί στην λειτουργία του συστήματος διαχείρησης μνήμης, ενώ το πρόγραμμα μπορεί να χρησιμοποιεί περισσότερη μνήμη από αυτήν που χρειάζεται επειδή ο garbage collector δεν γνωρίζει εάν ένα κομμάτι μνήμης μπορεί ακόμη να αποδεσμευθεί.
    \item Δυναμικοί τύποι δεδομένων.
        Γλώσσες όπως η Python επιτρέπουν τους τύπους δεδομένων των μεταβλητών να αλλάζουν δυναμικά κατά την εκτέλεση του προγράμματος.
        Αυτό, αν και απαλλάσει τον προγραμματιστή από την υποχρέωση να ορίζει πλήρως τον τύπο δεδομένων κάθε μεταβλητής, σημαίνει ότι κατά την εκτέλεση αναγκαστικά εκτελείται κώδικας που ελέγχει τον τύπο δεδομένων πριν την επεξεργασία τους, και δυναμικά αποφασίζει τι συμπεριφορά θα έχει το πρόγραμμα για τους δοθείσες τύπους δεδομένων.
\end{itemize}

Αυτοί οι τρείς παράγοντες, με την εξαίρεση πιθανόν των δυναμικών τύπων δεδομένων, αποτελούν παραδοσιακά σημεία επιλογής ανάμεσα σε ταχύτητα χρόνου εκτέλεσης και ευκολίας συγγραφής των προγραμμάτων.
Η Julia μέσω του ενδιαφέροντος τρόπου λειτουργίας της που θα περιγράψουμε παρακάτω, επιτυγχάνει έναν ενδιαφέρον συμβιβασμό σε σχέση και με τα τρία αυτά σχεδιαστικά διλλήματα.

Όσον αφορά τον συμβιβασμό ανάμεσα στην γρήγορη απόκριση της διερμηνείας και την παραγωγή αποδοτικού κώδικα με μεταγλώττιση, η Julia εισάγει ένα νέο πρότυπο που αποκαλεί Just-Ahead-of-Time compilation (JAOT).
Αυτό σημαίνει, ότι η Julia ξεκινάει σαν ένα διαδραστικό πρόγραμμα, αλλά κάθε φορά που ο χρήστης ζητάει από την Julia να εκτελέσει ένα κομμάτι κώδικα, ο κώδικας αυτός πρώτα μεταγλωτίζεται σε γλώσσα μηχανής της αρχιτεκτονικής πάνω στην οποία εκτελείται η Julia, και ύστερα εκτελείται.
Αυτή η προσέγγιση έχει το πλεονέκτημα ότι ο παραγόμενος κώδικας δεν υποφέρει από την χαμηλότερη ταχύτητα διερμηνείας, ενώ σε σύγκριση με γλώσσες που βασίζονται στην εκ των προτέρω μεταγλώττιση έχει το πλεονέκτημα ότι καθώς μεταγλωττίζεται αμέσως πριν την εκτέλεσή του, μπορεί να αξιοποιήσει εντολές της αρχιτεκτονικής που είναι συγκεκριμένα στο σύστημα στο οποίο εκτελείται.

Για την διαχείρηση μνήμης, η Julia χρησιμοποιεί ένα σύστημα Garbage Collection, επιτρέπει και ενθαρρύνει όμως την συγγραφή κώδικα του οποίου τμήματα (συνήθως το εσωτερικό βρόγχων) δεν καθυστερούν από τον garbage collector εφόσον δεν πραγματοποιούν κάποια λειτουργία που να τον απαιτεί όπως εκχώρηση μνήμης.
Καθώς, όπως αναφέραμε και προηγουμένως, ένα μεγάλο κομμάτι του χρόνου εκτέλεσης δαπανάται σε συγκεκριμένα κομμάτια του κώδικα, ο προγραμματιστής μπορεί αν εκμεταλευτεί την ευκολία της αυτόματης διαχείρησης μνήμης, αλλά ακολουθώντας κάποιους απλούς κανόνες να εξασφαλίσει ότι τα πιο υπολογιστικά δαπανηρά κομμάτια του κώδικα δεν καθυστερούν από την διαχείρηση αυτή.

Τέλος, η Julia έχει ένα σύστημα τύπων δεδομένων το οποίο επιτρέπει δυναμικούς τύπους δεδομένων κατά την εκτέλεση, αλλά εφόσον το πρόγραμμα είναι γραμμένο με τέτοιο τρόπο έτσι ώστε οι τύποι δεδομένων να μπορούν να βρεθούν από τον μεταγλωττιστή JAOT, ο παραγόμενος κώδικας είναι βελτιστοποιημένος για αυτούς τους τύπους δεδομένων και δεν προστίθεται λογική για τον χειρισμό της δυναμικότητας των τύπων δεδομένων κατά την εκτέλεση.
Επιπρόσθετα, καθώς ο κώδικας μεταγλωττίζεται αμέσως πριν την εκτέλεσή του, όπως θα δούμε και παρακάτω, ο μεταγλωττιστής έχει στην διάθεσή του περισσότερες πληροφορίες που μπορεί να χρησιμοποιήσει κατά την μεταγλώττιση όπως π.χ. τιμές οι οποίες είναι σταθερές κατά την εκτέλεση, οι οποίες μπορούν ενδεχομένως να οδήγησουν σε βελτιστοποιήσεις που ένας παραδοσιακός ahead-of-time μεταγλωττιστής δεν είναι δυνατό να πραγματοποιήσει.

\subsubsection{Βασικές έννοιες της γλώσσας}

Η Julia είναι ένα πρόγραμμα REPL.
Δεν υπάρχει κάποιος τρόπος να μεταγλωττίσουμε ένα αρχείο Julia σε standalone εκτελέσιμο (με την εξαίρεση πακέτων σε ανάπτυξη όπως το PackageBuilder.jl).
Αντίθετα, ξεκινάμε το περιβάλλον της Julia και εκτελούμε το πρόγραμμά μας από εκεί.

Κάθε έκφραση που δίνουμε στο REPL επεκτείνεται σε κλήση μίας ή περισσότερων συναρτήσεων (functions).
Για κάθε κλήση συνάρτησης, η Julia ξεκινάει με τον υπολογισμό των παραμέτρων της.
Αφού οι τιμές των παραμέτρων βρεθούν, με του τύπους δεδομένων τους διαθέσιμους ο μεταγλωττιστής ψάχνει να βρει μία υλοποίηση της συνάρτησης που να μπορεί να δεχθεί αυτούς τους τύπους δεδομένων.

Η αναζήτηση αυτή των συναρτήσεων προσδίδει στην γλώσσα το κύριο προγραμματιστικό χαρακτηριστικό της, τον λεγόμενο μηχανισμό \emph{multiple dispatch} (πολλαπλή διεκπαιρέωση).
Αυτό σημαίνει ότι ο πολυμορφισμός στην Julia πραγματοποιείται με τον ορισμό συναρτήσεων για τους διαφόρους τύπους δεδομένων.
Σε συνδιασμό με το γεγονός ότι μπορούμε να ορίσουμε συναρτήσεις που λειτουργούν με τύπους που δεν έχουμε ορίσει εμείς, αυτό παρέχει έναν πολύ εύχρηστο τρόπο συνδιασμού προγραμμάτων ιδιαίτερα συμβατό με τις ανάγκες αριθμητικών υπολογισμών.

Ως ένα παράδειγμα, ας υποθέσουμε ότι έχουμε ορίζει μία δομή δεδομένων για διδιάστατα διανύσματα ως εξής:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
struct Vector{F}
    x::F
    y::F
end
\end{jllisting}
}

και θέλουμε ο τελεστής πρόσθεσης \jlinl{+} να λειτουργεί με αυτόν τον τύπο.
Μπορούμε να ορίσουμε τις εξής βοηθητικές συναρτήσεις:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
import Base.+

function +(a::Vector, b::Vector)
    return Vector(a.x + b.x, a.y + b.y)
end

function +(x::Number, a::Vector)
    return Vector(x + a.x, x + a.y)
end

+(a::Vector, x::Number) = +(x, a)
\end{jllisting}
}

Έτσι μπορούμε να προσθέσουμε δύο διανύσματα τύπου \jlinl{Vector}, ή ένα τέτοιο διάνυσμα με μία βαθμωτή μεταβλητή, με τον μόνο περιορισμό να είναι οι υποκείμενοι τύποι να υποστηρίζουν τις λειτουργίες αυτές.
Στα διανύσματα που προκύπτουν, η Julia εκφέρει αυτόματα τον παραμετρικό τύπο \jlinl{F} του \jlinl{Vector}, και όλη η πολυμορφική συμπεριφορά περιορίζεται στο στάδιο της JOAT μεταγλώττισης.
Ο παραγώμενος κώδικας είναι συγκρίσιμος με αυτόν που θα προέκυπτε εάν γράφαμε ξεκάθαρα τις πράξεις χωρίς υψηλού επιπέδου παραμετρικούς τύπους δεδομένων.
Αυτός ο τρόπος πολυμορφικού προγραμματισμού αποτελεί την βάση της Julia, και όπως θα δούμε και παρακάτω, επιτρέπει ένα αρκετά υψηλού επιπέδου στυλ προγραμματισμού με τον κώδικα να θυμίζει σε μεγάλο βαθμό της μαθηματικές εκφράσεις που υλοποιεί.

\section{Επίλυση συνηθών διαφορικών εξισώσεων (ODEs)}

Όπως ίσως φαίνεται και από το παραπάνω παράδειγμα, η Julia ενθαρρύνει την συγγραφή κώδικα όπου αντί να ορίζουμε συγκεκριμένους τύπους δεδομένων με τους οποίους οι συναρτήσεις και δομές δεδομένων μας μπορούν να δουλέψουν, ορίζουμε έμμεσα μέσω του συστήματος multiple dispatch τις ιδιότητες που πρέπει να έχουν αυτοί οι τύποι.
Στο παραπάνω παράδειγμα, για να λειτουργεί ο κώδικας, αρκεί ο τύπος F να έχει ορισμένη την πράξη της πρόσθεσης με τον εαυτό του αλλά και με αριθμούς.
Πέρα από αυτόν τον περιορισμό, το F μπορεί να είναι οτιδήποτε, από βαθμωτή σταθερά μέχρι αραιός πίνακας με στοιχεία μιγαδικούς αριθμούς.
Όπως θα δούμε και παρακάτω, αυτή η ευελιξία μας επιτρέπει να εκφράσουμε και να επιλύσουμε αριθμητικά προβλήματα, όπως η επίλυση διαφορικών εξισώσεων, με έναν αρκετά ξεκάθαρο και άμεσο τρόπο.

Το κύριο πακέτο που χρησιμοποιείται για την επίλυση συνηθών διαφορικών εξισώσεων (ODE) είναι το OrdinaryDiffEq.jl, το οποίο είναι κομμάτι του γενικότερου πακέτου DifferentialEquations.jl \cite{Rackauckas2017}.
Το πακέτο αυτό μας επιτρέπει να λύσουμε προβλήματα διαφορικών εξισώσεων της μορφής:

\begin{align}
    \label{eq:ode-form}
    \frac{\mathrm{d}u}{\mathrm{d}t} &= f \left( u, p, t \right) \\
    u(t_1) &= u_0 \notag \\
    t &\in \left(t_1, t_2\right) \notag
\end{align}

Όπου $u$ η μεταβλητή την εξέλιξη της οποίας στον χρόνο ψάχνουμε, $p$ μία παράμετρος προς την συνάρτηση που υπολογίζει την παράγωγο της $u$, και $t$ ο χρόνος.

Έστω λοιπόν, ότι θέλουμε να λύσουμε το παρακάτω πρόβλημα της μορφής της εξίσωσης \eqref{eq:ode-form}:

\begin{align*}
    f(u, p, t) &= 0.98u \\
    u_0 = 1 \\
    t &\in (0, 1)
\end{align*}

Το μόνο που έχουμε να κάνουμε είναι να γράψουμε τους παραπάνω ορισμούς ως δηλώσεις Julia και να χρησιμοποιήσουμε το πακέτο OrdinaryDiffEq.jl ως εξής:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
f(u,p,t) = 0.98u
u0 = 1
tspan = (0.0,1.0)
prob = ODEProblem(f,u0,tspan)
sol = solve(prob, Tsit5())
\end{jllisting}
}

Η δεύτερη παράμετρος της solve(), καθορίζει τον αλγόριθμο χρονικής ολοκλήρωσης που θα χρησιμοποιηθεί, με τον Tsit5() να είναι ένας ολοκληρωτής βασισμένος στην μέθοδο Runge Kutta \cite{Tsitouras2011}.
Παρατηρούμε ότι πουθενά δεν χρειάστηκε να ορίσουμε τον τύπο δεδομένων του $u$, εκφέρεται αυτόματα από την Julia με βάση τον ορισμό του $u_0 = 1$ ως Float64 (αριθμός κινητής υποδιαστολής 64ων bit).

Δεν υπάρχει κάποιος περιορισμός όμως στο τι μπορεί να είναι το $u$, αρκεί μόνο ο τύπος δεδομένων του να υποστηρίζει τις πράξεις που απαιτεί ο ολοκληρωτής, κατά βάση πολλαπλασιασμό με σταθερά και πρόσθεση.
Εάν θέλουμε π.χ. να ολοκληρώσουμε αριθμητικά τις εξισώσεις Lorenz:

\begin{align*}
    \dot{x} &= \sigma (y - x) \\
    \dot{y} &= x(\rho - z) - y \\
    \dot{z} &= x y - \beta z
\end{align*}

μπορούμε να εκφράσουμε το πρόβλημά μας ως εξής:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
function lorenz!(du,u,p,t)
    du[1] = p[1]*(u[2]-u[1])
    du[2] = u[1]*(p[2]-u[3]) - u[2]
    du[3] = u[1]*u[2] - p[3]*u[3]
end

u0 = [1.0;0.0;0.0]
tspan = (0.0,10.0)
prob = ODEProblem(lorenz!, u0, tspan, [σ ρ β])
sol = solve(prob)
\end{jllisting}
}

όπου εδώ μάλιστα έχουμε γράψει την συνάρτηση υπολογισμού των παραγώγων με τέτοιον τρόπο έτσι ώστε να μην εκχωρεί καινούργια μνήμη σε κάθε επανάληψη, έναν από τους βασικούς κανόνες για υψηλή απόδοση στην Julia.

Δεν υπάρχει όμως κάτι που να περιορίζει το μέγεθος του $u$ σε μικρές διαστάσεις.
Μπορούμε κάλιστα να χρησιμοποιήσουμε μεγάλου μεγέθους διανύσματα που προκύπτουν από μια διακριτοποίηση με την μέθοδο των γραμμών, όπως περιγράφεται στην ενότητα \ref{seq:fvm-mol}.
Μάλιστα, όπως τονίσαμε και παραπάνω, το μόνο που χρειάζεται είναι να έχουν οριστεί για τον τύπο δεδομένων του $u$ η πράξεις της πρόσθεσης και του πολλαπλασιασμού με σταθερά, ή ότι άλλο εναλλακτικά απαιτεί ο ολοκληρωτής που χρησιμοποιούμε.
Για τον ενσωματομένο τύπο δεδομένων πινάκων \jlinl{Array}, η Julia έχει ήδη ορισμένες αρκετά αποδοτικές υλοποιήσεις αυτών των πράξεων.
Όπως θα δούμε στην επόμενη ενότητα, αυτή η ανεξαρτησία των αριθμητικών αλγορίθμων χρονικής ολοκλήρωσης από την υλοποίηση των αριθμητικών πράξεων θα μας επιτρέψει πολύ εύκολα να επιταχύνουμε τις πράξεις μας χρησιμοποιώντας άλλες αρχιτεκτονικές, όπως είναι οι κάρτες γραφικών.

\section{Επιτάχυνση της επίλυσης με χρήση καρτών γραφικών}

Το μεγαλύτερο κομμάτι του χρόνου εκτέλεσης για μία επίλυση διαφορικών εξισώσεων όπως αυτή της προηγούμενης ενότητας προέρχεται από τους παρακάτω δύο υπολογισμούς:

\begin{itemize}
    \item Υπολογισμός της χρονικής παραγώγου για κάθε στοιχείο του $u$.
    \item Με χρήση των παραγώγων, υπολογισμός της τιμής του $u$ για το επόμενο χρονικό βήμα.
\end{itemize}

Ανάλογα με τον αλγόριθμο ολοκλήρωσης, μπορεί να απαιτούνται πολλαπλοί υπολογισμοί των παραγώγων για κάθε χρονικό βήμα, αλλά ο τρόπος υπολογισμού αυτών κάθε φορά είναι ο ίδιος.

Όπως είδαμε στην ενότητα \ref{seq:fvm-mol}, ο υπολογισμός των παραγώγων κάθε στοιχείου δεν εξαρτάται μόνο από τις τιμές του $u$ την παρούσα χρονική στιγμή, και μπορεί να γίνει ξεχωριστά για κάθε στοιχείο.
Με άλλα λόγια ο υπολογισμός των παραγώγων είναι ένας έντονα παραλληλοποιήσιμος αλγόριθμος.
Η χρονική ολοκλήρωση αντίστοιχα, γίνεται κατά βάση και αυτή ξεχωριστά για κάθε στοιχείο, με τις βασικές λειτουργίες που απαιτούνται να είναι η άθροιση διανυσμάτων και ο πολλαπλασιασμός σταθεράς με διάνυσμα, πράξεις πλήρως παραλληλοποιήσιμες.

Βλέπουμε λοιπόν ότι οι πράξεις που απαιτούνται για την επίλυση μεγάλων συστημάτων συνηθών διαφορικών εξισώσεων, όπως αυτών που προκύπτουν από την μέθοδο των γραμμών, παρουσιάζουν παράλληλη δομή που επιτρέπει να μειωθεί δραματικά ο συνολικός χρόνος εκτέλεσης τους.
Καθώς ο παραλληλισμός σε αυτήν την περίπτωση αφορά την εκτέλεση ίδιων πράξεων σε πολλά στοιχεία ταυτόχρονα (Single Instruction Multiple Data/SIMD), έχουμε να κάνουμε με λεγόμενο παραλληλισμό δεδομένων (data-parallelism).
Η εκμετάλλευση αυτής της δυνατότητας παραλληλισμού με χρήση πολλαπλών πυρήνων του επεξεργαστή με κοινή μνήμη (shared memory parallelism) δεν απαιτεί μεγάλη προσπάθεια από μέρους μας.

Όσον αφορά την χρονική ολοκλήρωση, για πράξεις πυκνής γραμμικής άλγεβρας, η Julia από προεπιλογή χρησιμοποιεί την βιβλιοθήκη LAPACK και τις συναρτήσεις BLAS που αυτή παρέχει, με αποτέλεσμα οι πράξεις αυτές να εκτελούνται παράλληλα σε πολυπύρηνα συστήματα χωρίς να απαιτείται κάποια τροποποίηση του κώδικά μας.

Από την άλλη, η παραλληλοποίηση του υπολογισμού των παραγώγων εξαρτάται από την μορφή της συνάρτησης αυτής.
Μπορούμε να γράψουμε χειροκίνητα κώδικα που θα εκτελεστεί από πολλαπλά νήματα χρησιμοποιώντας την μακροεντολή Threads.@threads, που θυμίζει τον τρόπο προγραμματισμού που παρέχεται από το OpenMP.
Επιπλέον, υπάρχουν διάφορα πακέτα που μπορούν να παραλληλοποιήσουν εκφράσεις γραμμένες σε κώδικα υψηλού επιπέδου όπως το Tullio.jl \cite{Abbot2021}, που παραλληλοποιεί εκφράσεις γραμμένες με συμβολισμό Einstein notation.

Αν και η χρήση πολλαπλών πυρήνων του επεξεργαστή μπορεί να επιταχύνει σημαντικά την επίλυση του προβλήματος, οι μοντέρνες κάρτες γραφικών, ειδικά για προβλήματα που παρουσιάζουν έντονο παραλληλισμό δεδομένων, μας επιτρέπουν να πετύχουμε σημαντικά μεγαλύτερες ταχύτητες χωρίς να χρειαστεί να κατανομήσουμε το πρόβλημα μας σε ένα διανεμημένο σύστημα (distributed system) με την πολυπλοκότητα που προκύπτει από την απουσία της κοινής μνήμης (shared memory).
Η δυνατότητα αυτή προκύπτει από την εξέλιξη της αρχιτεκτονικής των καρτών γραφικών ως απόκριση στην ανάγκη της δυνατότητας προγραμματισμού των υπολογισμών που εκτελούνται κατά την σχεδιάση γραφικών (rendering).
Έτσι, αρκετές μοντέρνες κάρτες γραφικών παρέχουν πολλαπλές προγραμματιστικές διεπαφές (application programming interface/API), εκ των οποίων κάποιες προορίζονται για τις ανάγκες των γραφικών (π.χ. Vulkan, Direct3D, OpenGL), και άλλα για υπολογισμούς (όπως CUDA, HIP, OpenCL, SYCL, κ.α.).
Το μοντέλο προγραμματισμού που παρέχεται για υπολογισμούς, μας επιτρέπει να αντιμετωπίζουμε την κάρτα γραφικών ως ένα σύστημα MIMD \cite{Patterson2017}.

Καθώς η αρχιτεκτονική και ο τρόπος εκτέλεσης αριθμητικών υπολογισμών από μία κάρτα γραφικών διαφέρουν έντονα ανάμεσα σε διάφορες κάρτες \cite{Patterson2017}, στο σημείο αυτό, ας δούμε πώς μπορούμε να λύσουμε ένα σύστημα ODE της μορφής:

\begin{equation*}
    \frac{\mathrm{d}\mathbf{u}}{\mathrm{d}t} = \mathbf{A} \mathbf{u}
\end{equation*}

αξιοποιώντας τις δυνατότητες επιτάχυνσης που παρέχονται στην Julia, με κάρτες γραφικών που υποστηρίζουν το μοντέλο προγραμματισμού της CUDA.

{\large
\begin{jllisting}[language=julia, style=jlcodestyle]
using CUDA, LinearAlgebra

A = ... |> cu
u0 = ... |> cu

function f!(du, u, p, t)
    mul!(du, A, u)
end

tspan = (0.0, 1.0)
prob = ODEProblem(f!, u0, tspan)
sol = solve(prob)
\end{jllisting}
}

Παρατηρούμε ότι η μόνη διαφορά με το αντίστοιχο πρόγραμμα που δεν αξιοποιεί την επιτάχυνση με CUDA, είναι η μεταφορά των πινάκων \texttt{A} και \texttt{u} στον χώρο μνήμης (memory space) της κάρτας γραφικών με την συνάρτηση \texttt{cu}.
Ο τρόπος με τον οποίο είναι δυνατόν να γράψουμε κώδικα που αξιοποιεί τις δυαντότητες επιτάχυνσης GPU χωρίς να χρειάζεται να κάνουμε μεγάλες αλλαγές στην συγκεκριμένη περίπτωση, βασίζεται στο σύστημα multiple dispatch της Julia.

Πιο συγκεκριμένα, το πακέτο CUDA ορίζει τον τύπο \jlinl{CuArray}, ο οποίος αντιπροσωπεύει έναν πίνακα του οποίου τα περιεχόμενα είναι αποθηκευμένα στην μνήμη της κάρτας γραφικών.
Η συνάρτηση \jlinl{cu}, επιτρέπει την κατασκευή ενός \jlinl{CuArray} από έναν κανονικό πίνακα \jlinl{Array}, το οποίο ισοδυναμεί με την αντιγραφή δεδομένων από την κύρια μνήμη του συστήματος στην μνήμη της GPU.

Ύστερα, καθώς ο τύπος του \jlinl{u0} είναι \jlinl{CuArray}, ο επιλυτής θα χρησιμοποιήσει τον ίδιο τύπο δεδομένων για να αποθηκεύσει την λύση σε κάθε βήμα.
Κατά τον υπολογισμό των παραγώγων, η \jlinl{f!} θα κληθεί με τα \jlinl{du} και \jlinl{u} να είναι \jlinl{CuArray}, και κατά συνέπεια, η \jlinl{mul!} θα κληθεί με τύπους \jlinl{(::CuArray\{T, 1\}, ::CuArray\{T, 2\}, ::CuArray\{T, 1\})} όπου \jlinl{T} ο τύπος των στοιχείων των \jlinl{A} και \jlinl{u}, συνήθως \jlinl{Float32} ή \jlinl{Float64}.

Η \jlinl{mul!} είναι μία συνάρτηση του βασικού πακέτου \jlinl{LinearAlgebra}, η οποία πολλαπλασιάζει δύο πίνακες και αποθηκεύει το αποτέλεσμα στην πρώτη παράμετρό της, επιτρέποντάς μας να πολλαπλασιάσουμε πίνακες και διανύσματα χωρίς να χρειαστεί να κατανέμουμε ξεχωριστό κομμάτι μνήμης για κάθε αποτέλεσμα.
Στο πακέτο \jlinl{LinearAlgebra}, αυτή η συνάρτηση υλοποιείται για τον τύπο \jlinl{Array}, όπου καλεί τις συναρτήσεις BLAS, οι οποίες συνήθως κάνουν χρήση πολλαπλών νημάτων και έτσι αξιοποιούν πολλαπλούς πυρήνες του επεξεργαστή.
Το πακέτο \jlinl{CUDA} αντίστοιχα παρέχει υλοποιήσεις της \jlinl{mul!} για τον τύπο \jlinl{CuArray}, οι οποίες ανάλογα με τον τύπο δεδομένων του πίνακα, είτε καλούν συναρτήσεις από την βιβλιοθήκη cuBLAS της NVIDIA, είτε καλούν ειδικούς πυρήνες γραμμένους σε Julia που πραγματοποιούν τον πολλαπλασιασμό για τύπους δεδομένων που δεν υποστήρίζονται από το cuBLAS, όπως π.χ. μιγαδικούς αριθμούς.
Επιπρόσθετα, το πακέτο \jlinl{CUDA} παρέχει υλοποιήσεις πρόσθεσης και πολλαπλασιασμού με σταθερά, υλοποιώντας π.χ. την συνάρτηση \jlinl{Base.+} για πίνακες \jlinl{CuArray}, το οποίο σημαίνει ότι η εκτέλεση αυτών των πράξεων από τον χρονικό ολοκληρωτή επίσης θα εκτελεστούν με επιτάχυνση από την κάρτα γραφικών, χωρίς να χρειάζεται μία χρονοβόρα μεταφορά πίσω στο κύρια μνήμη του συστήματος για επεξεργασία από τον κύριο επεξεργαστή.

Αυτό το στυλ προγραμματισμού GPU με Julia αναφέρεται ως στυλ προγραμματισμού υψηλού επιπέδου (high-level).
Υπάρχουν όμως περιπτώσεις όπου θέλουμε να πραγματοποιήσουμε κάποιον υπολογισμό που δεν μπορούμε να υλοποιήσουμε αποδοτικά ως σύνθεση των έτοιμα διαθέσιμων υπολογισμών.
Σε αυτήν την περίπτωση είναι αναγκαία η συγγραφή ενός ειδικού πυρήνα (custom kernel).
Το πακέτο CUDA, εκμεταλλευόμενο τις δυνατότητες μετα-προγραμματισμού (meta-programming) της Julia, επιτρέπει την συγγραφή και εκτέλεση πυρήνων με τρόπο αρκετά παρόμοιο με αυτόν που παρέχεται από την NVIDIA με την γλώσσα CUDA C++.
Ως παράδειγμα, μπορούμε να δούμε έναν πυρήνα, προσαρμοσμένο από την τεκμηρίωση του \jlinl{CUDA.jl}, για την εκτέλεση της πράξης $\mathbf{y} \leftarrow \mathbf{y} + \mathbf{x}$ όπου $\mathbf{x}$ και $\mathbf{y}$ δύο διανύσματα μήκους \jlinl{N}:

{\large
\begin{jllisting}[language=julia,style=jlcodestyle]
function gpu_accumulate!(y, x)
    index = (blockIdx().x - 1) * blockDim().x + threadIdx().x
    stride = blockDim().x * gridDim().x
    for i = index:stride:length(y)
        @inbounds y[i] += x[i]
    end
    return
end

numblocks = ceil(Int, N/256)

@cuda threads=256 blocks=numblocks gpu_accumulate!(y, x)
\end{jllisting}
}

Μέσα στον πυρήνα, μπορούμε να χρησιμοποιήσουμε ένα μεγάλο κομμάτι των δυνατοτήτων της Julia, με την εξαίρεση π.χ. λειτουργιών που απαιτούν την εκχώρηση μνήμης.

Βλέπουμε λοιπόν, ότι η Julia σε συνδιασμό με το οικοσύστημα πακέτων που έχουν αναπτυχθεί με βάση τις δυνατότητες της γλώσσας, μας παρέχουν την δυνατότητα της πλήρης αξιοποίησης του υλικού, αλλά παράλληλα ένα σύνολο αφαιρέσεων (abstractions), πάνω στις οποίες μπορούμε να εκφράσουμε περίπλοκους υπολογισμούς με ιδιαίτερα εκφραστικό και ευανάγνωστο κώδικα υψηλού επιπέδου.
Στο επόμενο κεφάλαιο θα δούμε πώς το πακέτο που αναπτύχθηκε στα πλαίσια αυτής της διπλωματικής εργασίας \jlinl{Shockwave.jl}, αξιοποιεί αυτές τις δυνατότητες για να παρέχει έναν εύκολο τρόπο περιγραφής και επίλυσης προβλημάτων που προκύπτουν από νόμους διατήρησης (conservation laws) με έμφαση στην επίλυση των εξισώσεων Euler με πεπερασμένους όγκους πρώτης τάξης (first order FVM).

