\chapter{Επίλυση διαφορικών εξισώσεων με Julia}

Σε αυτό το κεφάλαιο θα ασχοληθούμε με τον τρόπο λειτουργίας της γλώσσας προγραμματισμού Julia και τις τεχνικές επίλυσης διαφορικών εξισώσεων με αυτήν.
Θα εξετάσουμε επίσης της δυνατότητες προγραμματισμού καρτών γραφικών που παρέχονται από τα πακέτα της ομάδας JuliaGPU.

\section{Η γλώσσα προγραμματισμού Julia}

\subsection{Το πρόβλημα των δύο γλωσσών}

Όπως αναφέρθηκε και στην εισαγωγή, η Julia στοχεύει στην επίλυση του λεγόμενου \emph{προβλήματος των 2 γλωσσών}.
Το πρόβλημα αυτό είναι προϊόν της μέχρι τώρα αρνητικής συσχέτισης ανάμεσα στην εκφραστικότητα μίας γλώσσας προγραμματισμού και την απόδοση ιδιωματικού κώδικα σε αυτήν.
Με άλλα λόγια, η πρωτοτυποποίηση ενός αλγορίθμου μπορεί να γραφεί εύκολα σε μία γλώσσα όπως η Python, αλλά αυτό μπορεί να συνεπάγεται μιας απώλειας σε ταχύτητα μίας τάξης μεγέθους.
Ως αποτέλεσμα, είναι συνήθες επιστήμονες ή μηχανικοί να γράφουν αρχικά μία υλοποίηση του αλγορίθμου που θέλουν να εκτελέσουν σε μία αργή αλλά υψηλού επιπέδου γλώσσα προκειμένου να ελέγξουν την ορθότητα του, και ύστερα να ξαναγράφουν αυτόν τον αλγόριθμο σε μία γλώσσα όπως η C++ ή η Fortran προκειμένου να επιτύχουν καλή ταχύτητα.

Ένας τρόπος επίλυσης αυτού του προβλήματος προκύπτει από την παρατήρηση ότι ο περισσότερος χρόνος εκτέλεσης προκαλείται από ένα κομμάτι του προγράμματος σημαντικά μικρότερο από το σύνολο του κώδικα του προγράμματος.
Κατά βάση, αυτός είναι ο κώδικας που βρίσκεται στο εσωτερικό βρόγχων, ειδικά όταν αυτοί οι βρόγχοι βρίσκονται ο ένας μέσα στον άλλον, και μπορεί να είναι π.χ. ο κώδικας που εκτελεί ένα βήμα μίας επαναληπτικής αριθμητικής μεθόδου.
Μπορούμε λοιπόν να απομονώσουμε αυτά τα κομμάτια κώδικα και να τα γράψουμε σε μία γλώσσα χαμηλού επιπέδου και υψηλής απόδοσης, ενώ ο υπόλοιπος συνδετικός κώδικας ο οποίος συνεισφέρει ένα αμελητέο κομμάτι του χρόνου εκτέλεσης μπορεί να γραφεί σε μία γλώσσα υψηλού επιπέδου.

Αυτή η προσέγγιση χρησιμοποιείται κατά κόρον σε συστήματα μηχανιστικής μάθησης (machine learning) όπως το TensorFlow και το PyTorch, όπου η γλώσσα χαμηλού επιπέδου είναι η C++ (και διαλέκτοι της C++ για προγραμματισμό καρτών γραφικών όπως η CUDA ή το HIP) ενώ η γλώσσα υψηλού επιπέδου είναι η Python ή και η Swift στην περίπτωση του TensorFlow.
Αυτή η αρχιτεκτονική έχει δουλέψει αρκετά καλά για την περίπτωση των νευρωνικών δικτύων (neural networks) όπου μεγάλο μέρος της έρευνας είναι ο σωστός συνδιασμός γνωστών block έτσι ώστε ένα πρόβλημα να επιλυθεί με ικανοποιητική ακρίβεια.
Μάλιστα, είναι αρκετά συχνό ένα ερευνητικό αποτέλεσμα να διανέμεται ως μίξη κώδικα υψηλού επιπέδου και κειμένου με την μορφή διαδραστικών notebook, με την χαμηλού επιπέδου υλοποίηση των αλγορίθμων μάθησης να μην αναφέρεται καν.

Ο διαχωρισμός ανάμεσα σε γρήγορο και αργό κώδικα όμως, έχει μία σειρά από μειονεκτήματα:
Αρχικά, όλη η επικοινωνία ανάμεσα στις δύο γλώσσες μπορεί να γίνει με τον μέγιστο κοινό διαιρέτη των δυνατοτήτων τους, το οποίο στην πράξη συνήθως σημαίνει ότι ο χαμηλού επιπέδου κώδικας παρέχει μία διεπαφή (interface) από συναρτήσεις C.
Αυτό σημαίνει ότι είναι αδύνατον π.χ. ο κώδικας σε C++ να χρησιμοποιήσει μία ανώνυμη συνάρτηση (ή αλλιώς συνάρτηση λάμδα), ορισμένη στον υψηλού επιπέδου κώδικα σε Python, παρόλο που και οι δύο γλώσσες υποστηρίζουν συναρτήσεις ως τύπους δεδομένων.

Ύστερα, κατά την συγγραφή του χαμηλού επιπέδου κώδικα, συνεχίζουμε να αναγκαζόμαστε να υλοποιήσουμε τον αλγόριθμό μας στην γλώσσα υψηλού επιπέδου για να τον επαληθεύσουμε, εκτός εάν η λογική του είναι αρκετά απλή και προφανής.
Με άλλα λόγια, η συγγραφή του χαμηλού επιπέδου κώδικα είναι πιο χρονοβόρα καθώς δεν μπορούμε να χρησιμοποιήσουμε χρήσιμα χαρακτηριστικά γλωσσών υψηλού επιπέδου, όπως δυναμικούς τύπους ή διαδραστικά περιβάλλοντα ανάπτυξης με γρήγορο χρόνο απόκρισης στις αλλαγές μας όπως notebook ή συστήματα REPL.

Τέλος, καθώς τροποποιήσεις στον χαμηλού επιπέδου κώδικα είναι σημαντικά δυσκολότερες, χρήστες και ερευνητές αποθαρρύνονται σημαντικά από το να κάνουν πειράματα που απαιτούν τροποποιήσεις των χαμηλού επιπέδου αλγορίθμων.
Αυτό αυξάνει τον φόρτο εργασίας των προγραμματιστών που αναπτύσουν αυτόν τον κώδικα, και μειώνει το κίνητρο για την υλοποίηση πειραματικών, μή δοκιμασμένων υπολογιστικών τεχνικών, καθώς το κόστος υλοποίησής τους είναι πολύ μεγάλο, ειδικά για χρήστες που δεν έχουν επιρροή στην ομάδα ανάπτυξης των βιβλιοθηκών αυτών.

\subsection{Το μοντέλο προγραμματισμού της γλώσσας Julia}

\subsubsection{Σχεδιαστικές επιλογές}

Στην προηγούμενη ενότητα αναφερθήκαμε στο πρόβλημα των δύο γλωσσών, και στην επιλογή ανάμεσα σε μία αργή αλλά υψηλού επιπέδου γλώσσας και μία γρήγορη αλλά χαμηλού επιπέδου γλώσσα.
Υπάρχουν αρκετοί παράγοντες για την διαφορά σε απόδοση ανάμεσα σε ιδιοματικά προγράμματα ανάμεσα σε δύο γλώσσες, αλλά τα παρακάτω χαρακτηριστικά μίας γλώσσας μπορούν να έχουν σημαντικό αντίκτυπο στην απόδοσή της:

\begin{itemize}
    \item Διερμηνεία (interpretation) αντί μεταγλώττισης (compilation).
        Πολλές υψηλού επιπέδου γλώσσες (π.χ. Python, Lua, Ruby) αλλά όχι όλες εκτελούνται μέσω διερμηνείας (interpreted languages).
        Αυτό σημαίνει ότι ο χρόνος εκτέλεσης περιλαμβάνει τον χρόνο συντακτικής ανάλυσης και κατανόησης του πηγαίου κώδικα από την μηχανή εκτέλεσης.
        Προς μείωση αυτού του χρόνου, γλώσσες όπως η Python παρέχουν έναν τρόπο αποθήκευσης κώδικα μετά το στάδιο του parsing μειώνοντας κάπως τον χρόνο της διερμηνείας, αλλά η συντακτική ανάλυση παραμένει μία υπολογιστικά ακριβή διαδικασία.
        Ένα δεύτερο αρνητικό αποτέλεσμα της διερμηνείας είναι ότι οι αλγόριθμοι και οι βελτιστοποιήσεις που μπορεί να εκτελέσει το σύστημα διερμηνείας πρέπει αναγκαστικά να είναι σχετικά απλοί και γρήγοροι, το οποίο επίσης αυξάνει τον χρόνο εκτέλεσης.
    \item Τρόπος διαχείρησης μνήμης. Οι υψηλού επιπέδου γλώσσες έχουν κατά κανόνα ένα σύστημα αυτόματης διαχείρησης μνήμης με την μορφή ενός Garbage Collector (GC).
        Αυτό κάνει την συγγραφή προγραμμάτων σημαντικά ευκολότερη καθώς ο προγραμματιστής δεν χρειάζεται να ασχοληθεί με τον χρόνο για τον οποίο μία εκχώρηση μνήμης είναι απαραίτητη και πότε αυτή μπορεί να αποδεσμευθεί.
        Αποφεύγονται επίσης μία σειρά από συχνά λάθη προγραμματισμού σχετικά με την διαχείρηση μνήμης (double-free, null pointer exception κ.α.), το οποίο μπορεί να μειώσει σημαντικά τον χρόνο ανάπτυξης.
        Το κόστος για αυτά τα πλεονεκτήματα είναι ότι αναγκαστικά ένα κομμάτι του χρόνου εκτέλεσης θα πρέπει να αφιερωθεί στην λειτουργία του συστήματος διαχείρησης μνήμης, ενώ το πρόγραμμα μπορεί να χρησιμοποιεί περισσότερη μνήμη από αυτήν που χρειάζεται επειδή ο garbage collector δεν γνωρίζει εάν ένα κομμάτι μνήμης μπορεί ακόμη να αποδεσμευθεί.
    \item Δυναμικοί τύποι δεδομένων.
        Γλώσσες όπως η Python επιτρέπουν τους τύπους δεδομένων των μεταβλητών να αλλάζουν δυναμικά κατά την εκτέλεση του προγράμματος.
        Αυτό, αν και απαλλάσει τον προγραμματιστή από την υποχρέωση να ορίζει πλήρως τον τύπο δεδομένων κάθε μεταβλητής, σημαίνει ότι κατά την εκτέλεση αναγκαστικά εκτελείται κώδικας που ελέγχει τον τύπο δεδομένων πριν την επεξεργασία τους, και δυναμικά αποφασίζει τι συμπεριφορά θα έχει το πρόγραμμα για τους δοθείσες τύπους δεδομένων.
\end{itemize}

Αυτοί οι τρείς παράγοντες, με την εξαίρεση πιθανόν των δυναμικών τύπων δεδομένων, αποτελούν παραδοσιακά σημεία επιλογής ανάμεσα σε ταχύτητα χρόνου εκτέλεσης και ευκολίας συγγραφής των προγραμμάτων.
Η Julia μέσω του ενδιαφέροντος τρόπου λειτουργίας της που θα περιγράψουμε παρακάτω, επιτυγχάνει έναν ενδιαφέρον συμβιβασμό σε σχέση και με τα τρία αυτά σχεδιαστικά διλλήματα.

Όσον αφορά τον συμβιβασμό ανάμεσα στην γρήγορη απόκριση της διερμηνείας και την παραγωγή αποδοτικού κώδικα με μεταγλώττιση, η Julia εισάγει ένα νέο πρότυπο που αποκαλεί Just-Ahead-of-Time compilation (JAOT).
Αυτό σημαίνει, ότι η Julia ξεκινάει σαν ένα διαδραστικό πρόγραμμα, αλλά κάθε φορά που ο χρήστης ζητάει από την Julia να εκτελέσει ένα κομμάτι κώδικα, ο κώδικας αυτός πρώτα μεταγλωτίζεται σε γλώσσα μηχανής της αρχιτεκτονικής πάνω στην οποία εκτελείται η Julia, και ύστερα εκτελείται.
Αυτή η προσέγγιση έχει το πλεονέκτημα ότι ο παραγόμενος κώδικας δεν υποφέρει από την χαμηλότερη ταχύτητα διερμηνείας, ενώ σε σύγκριση με γλώσσες που βασίζονται στην εκ των προτέρω μεταγλώττιση έχει το πλεονέκτημα ότι καθώς μεταγλωττίζεται αμέσως πριν την εκτέλεσή του, μπορεί να αξιοποιήσει εντολές της αρχιτεκτονικής που είναι συγκεκριμένα στο σύστημα στο οποίο εκτελείται.

Για την διαχείρηση μνήμης, η Julia χρησιμοποιεί ένα σύστημα Garbage Collection, επιτρέπει και ενθαρρύνει όμως την συγγραφή κώδικα του οποίου τμήματα (συνήθως το εσωτερικό βρόγχων) δεν καθυστερούν από τον garbage collector εφόσον δεν πραγματοποιούν κάποια λειτουργία που να τον απαιτεί όπως εκχώρηση μνήμης.
Καθώς, όπως αναφέραμε και προηγουμένως, ένα μεγάλο κομμάτι του χρόνου εκτέλεσης δαπανάται σε συγκεκριμένα κομμάτια του κώδικα, ο προγραμματιστής μπορεί αν εκμεταλευτεί την ευκολία της αυτόματης διαχείρησης μνήμης, αλλά ακολουθώντας κάποιους απλούς κανόνες να εξασφαλίσει ότι τα πιο υπολογιστικά δαπανηρά κομμάτια του κώδικα δεν καθυστερούν από την διαχείρηση αυτή.

Τέλος, η Julia έχει ένα σύστημα τύπων δεδομένων το οποίο επιτρέπει δυναμικούς τύπους δεδομένων κατά την εκτέλεση, αλλά εφόσον το πρόγραμμα είναι γραμμένο με τέτοιο τρόπο έτσι ώστε οι τύποι δεδομένων να μπορούν να βρεθούν από τον μεταγλωττιστή JAOT, ο παραγόμενος κώδικας είναι βελτιστοποιημένος για αυτούς τους τύπους δεδομένων και δεν προστίθεται λογική για τον χειρισμό της δυναμικότητας των τύπων δεδομένων κατά την εκτέλεση.
Επιπρόσθετα, καθώς ο κώδικας μεταγλωττίζεται αμέσως πριν την εκτέλεσή του, όπως θα δούμε και παρακάτω, ο μεταγλωττιστής έχει στην διάθεσή του περισσότερες πληροφορίες που μπορεί να χρησιμοποιήσει κατά την μεταγλώττιση όπως π.χ. τιμές οι οποίες είναι σταθερές κατά την εκτέλεση, οι οποίες μπορούν ενδεχομένως να οδήγησουν σε βελτιστοποιήσεις που ένας παραδοσιακός ahead-of-time μεταγλωττιστής δεν είναι δυνατό να πραγματοποιήσει.

\subsubsection{Βασικές έννοιες της γλώσσας}

Η Julia είναι ένα πρόγραμμα REPL.
Δεν υπάρχει κάποιος τρόπος να μεταγλωττίσουμε ένα αρχείο Julia σε standalone εκτελέσιμο (με την εξαίρεση πακέτων σε ανάπτυξη όπως το PackageBuilder.jl).
Αντίθετα, ξεκινάμε το περιβάλλον της Julia και εκτελούμε το πρόγραμμά μας από εκεί.

Κάθε έκφραση που δίνουμε στο REPL επεκτείνεται σε κλήση μίας ή περισσότερων συναρτήσεων (functions).
Για κάθε κλήση συνάρτησης, η Julia ξεκινάει με τον υπολογισμό των παραμέτρων της.
Αφού οι τιμές των παραμέτρων βρεθούν, με του τύπους δεδομένων τους διαθέσιμους ο μεταγλωττιστής ψάχνει να βρει μία υλοποίηση της συνάρτησης που να μπορεί να δεχθεί αυτούς τους τύπους δεδομένων.

Η αναζήτηση αυτή των συναρτήσεων προσδίδει στην γλώσσα το κύριο προγραμματιστικό χαρακτηριστικό της, τον λεγόμενο μηχανισμό \emph{multiple dispatch} (πολλαπλή διεκπαιρέωση).
Αυτό σημαίνει ότι ο πολυμορφισμός στην Julia πραγματοποιείται με τον ορισμό συναρτήσεων για τους διαφόρους τύπους δεδομένων.
Σε συνδιασμό με το γεγονός ότι μπορούμε να ορίσουμε συναρτήσεις που λειτουργούν με τύπους που δεν έχουμε ορίσει εμείς, αυτό παρέχει έναν πολύ εύχρηστο τρόπο συνδιασμού προγραμμάτων ιδιαίτερα συμβατό με τις ανάγκες αριθμητικών υπολογισμών.

Ως ένα παράδειγμα, ας υποθέσουμε ότι έχουμε ορίζει μία δομή δεδομένων για διδιάστατα διανύσματα ως εξής:

\begin{jllisting}[language=julia]
struct Vector{F}
    x::F
    y::F
end
\end{jllisting}

και θέλουμε ο τελεστής πρόσθεσης \jlinl{+} να λειτουργεί με αυτόν τον τύπο.
Μπορούμε να ορίσουμε τις εξής βοηθητικές συναρτήσεις:

\begin{jllisting}[language=julia]
import Base.+

function +(a::Vector, b::Vector)
    return Vector(a.x + b.x, a.y + b.y)
end

function +(x::Number, a::Vector)
    return Vector(x + a.x, x + a.y)
end

+(a::Vector, x::Number) = +(x, a)
\end{jllisting}

Έτσι μπορούμε να προσθέσουμε δύο διανύσματα τύπου \jlinl{Vector}, ή ένα τέτοιο διάνυσμα με μία βαθμωτή μεταβλητή, με τον μόνο περιορισμό να είναι οι υποκείμενοι τύποι να υποστηρίζουν τις λειτουργίες αυτές.
Στα διανύσματα που προκύπτουν, η Julia εκφέρει αυτόματα τον παραμετρικό τύπο \jlinl{F} του \jlinl{Vector}, και όλη η πολυμορφική συμπεριφορά περιορίζεται στον στάδιο της JOAT μεταγλώττισης.
Ο παραγώμενος κώδικας είναι συγκρίσιμος με αυτόν που θα προέκυπτε εάν γράφαμε ξεκάθαρα τις πράξεις χωρίς υψηλού επιπέδου παραμετρικούς τύπους δεδομένων.

\section{DifferentialEquations.jl}

% julia programming model, juliaGPU (CUDA, etc.), code reuse and ecosystem

\section{Προγραμματισμός καρτών γραφικών}

